import numpy as np
class LinearRegression:
    
    def __init__(self,lr=0.001, iter=1000):
        
        self.lr = lr
        self.iter = iter
        self.weights=None
        self.bias=None
        
        
    def fit(self,X,y):
        
        n_sample,n_feature=X.shape              #X.shape=r,c  row =number sample, col=number of feature
        
        self.weights=np.zeros(n_feature)
        self.bias=0
        
        for _ in range(self.iter):
            y_predict=np.dot(X,self.weights)+self.bias        # y=wx+b          
            dw=(1/n_sample) * np.dot(X.T,(y_predict-y))      #(1/N)*2xi(yi-ypi)
            db=(1/n_sample) * np.sum(y_predict-y)            #((1/N)*2(yi-yp))               
            self.weights-=self.lr*dw                      #dw=dw-lr*dw
            self.bias-=self.lr*db                         #db=db-lr*db    
            
            
            
    def predict(self,X):
        y_predict=np.dot(X,self.weights)+self.bias
        return y_predict
            
            
  #create Datasets for validation

from sklearn.model_selection import train_test_split
from sklearn import datasets
import matplotlib.pyplot as plt

X,y=datasets.make_regression(n_samples=100,
    n_features=1, noise=20,random_state=4)

X_train,X_test,Y_train,Y_test=train_test_split(X,y,test_size=0.2,random_state=1234)


reg=LinearRegression(lr=0.01)
reg.fit(X_train,Y_train)
predict=reg.predict(X_test)

def mse(y_true,y_predicted):
    
    return np.mean((y_true-y_predicted)**2)

mse(Y_test,predict)
